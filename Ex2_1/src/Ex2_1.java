import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.io.File;
import java.io.FileWriter;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.IOException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class Ex2_1 extends Thread {

    /**
     * + Function to create n files, each file create with random number (generated by the seed) of lines between 0 to bound
     *
     * @return files
     */
    public static String[] createTextFiles(int n, int seed, int bound) {

        Random random = new Random(seed);
        String[] fileNames = new String[n];

        for (int i = 0; i < n; i++) {
            // l is to create file numbers from "file_1" instead of "file_0"
            int l = i + 1;
            String fileName = "file_" + l;
            fileNames[i] = fileName;

            // Create a new file
            File file = new File(fileName);

            try {
                // Open the file for writing
                FileWriter writer = new FileWriter(file);
                //Generate a random number of rows
                int x = random.nextInt(bound);

                for (int j = 0; j < x; j++) {
                    writer.write("Aaron and Itamar" + "\n");
                }
                // Close the file
                writer.close();
            } catch (IOException e) {
                System.out.println("An error occurred while trying to create the file.");
                e.printStackTrace();
            }
        }
        return fileNames;
    }

    /**
     * Function that count the lines of all the files
     *
     * @return The number of lines
     */

    public static int getNumOfLines(String[] fileNames) {

        int numLines = 0;
        for (int i = 0; i < fileNames.length; i++) {
            try {
                // Open every file for reading
                FileReader filereader = new FileReader(fileNames[i]);
                //Convert from Filereader to BufferedReader to be capacite to read a line at a time
                BufferedReader lineReader = new BufferedReader(filereader);

                // Read each line of the file until is get empty and count it
                while ((lineReader.readLine()) != null) {
                    numLines++;
                }
                // Close the file
                lineReader.close();
            } catch (IOException e) {
                System.out.println("An error occurred while trying to read the file.");
                e.printStackTrace();
            }
        }

        return numLines;

    }

    /**
     * Function that count the lines of all the files with thread
     *
     * @return The number of lines
     */
    public static int getNumOfLinesThreads(String[] fileNames) {
        THREAD[] threads = new THREAD[fileNames.length];

        // We will create a thread for each file
        for (int i = 0; i < fileNames.length; i++) {
            threads[i] = new THREAD(fileNames[i]);
        }

        // Start each thread
        for (THREAD thread : threads) {
            thread.start();
        }

        // Wait for each thread to finish
        for (THREAD thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        // Sum the number of lines from each thread
        int numLines = 0;
        for (THREAD thread : threads) {
            numLines += thread.getNumLines();
        }

        return numLines;
    }

    /**
     * Function to count the lines of all the files with ThreadPool
     *
     * @return The number of lines
     */
    public static int getNumOfLinesThreadPool(String[] fileNames) {

        int count = 0;
        try {
            List<Future<Integer>> tasks = new ArrayList<>();
            ExecutorService pool = Executors.newFixedThreadPool(fileNames.length);

            for (int i = 0; i < fileNames.length; i++) {
                Future<Integer> task = pool.submit(new CALLABLE(fileNames[i]));
                tasks.add(task);
            }
            for (Future task : tasks) {
                count += (int) task.get();
            }
            pool.shutdown();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return count;

    }

}

